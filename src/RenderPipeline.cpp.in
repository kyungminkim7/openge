#include <array>
#include <type_traits>
#include <vector>

#include <openge/Camera.hpp>
#include <openge/GLShader.hpp>
#include <openge/GLShaderProgram.hpp>
#include <openge/GameObject.hpp>
#include <openge/RenderPipeline.hpp>
#include <openge/Transform.hpp>

namespace {

constexpr std::array<const char *, 1> VERTEX_SHADERS {
    R"-(${STANDARD_VERT})-"
};

constexpr std::array<const char *, 1> FRAGMENT_SHADERS {
    R"-(${STANDARD_FRAG})-"
};

std::vector<std::shared_ptr<ge::GLShaderProgram>> shaderPrograms(1, nullptr);

}  // namespace

namespace ge::RenderPipeline {

namespace Attribute {
    const char *POSITION = "aPosition";
    const char *NORMAL = "aNormal";
    const char *TEXTURE_COORDINATE = "aTextureCoordinate";
}  // namespace Attribute

namespace Uniform {
    const char *MODEL = "model";
    const char *VIEW = "view";
    const char *PROJECTION = "projection";

    namespace Material {
        const char *COLOR = "color";
        const std::vector<const char *> TEXTURES {
            "texture0",
            "texture1",
            "texture2",
            "texture3",
            "texture4",
            "texture5",
            "texture6",
            "texture7",
            "texture8",
            "texture9",
            "texture10",
            "texture11",
            "texture12",
            "texture13",
            "texture14",
            "texture15",
        };
    }  // namespace Material
}  // namespace Uniform

void destroy() {
    shaderPrograms.assign(shaderPrograms.size(), nullptr);
}

std::shared_ptr<GLShaderProgram> getShaderProgram(Program program) {
    const auto index =
        static_cast<std::underlying_type_t<Program>>(program);

    auto &shaderProgram = shaderPrograms[index];
    if (shaderProgram == nullptr) {
        shaderProgram = std::make_shared<GLShaderProgram>();
        shaderProgram->create();

        shaderProgram->addShaderFromSourceCode(
            GLShader::ShaderTypeBit::Vertex,
            VERTEX_SHADERS[index]);

        shaderProgram->addShaderFromSourceCode(
            GLShader::ShaderTypeBit::Fragment,
            FRAGMENT_SHADERS[index]);

        shaderProgram->link();
    }

    return shaderProgram;
}

void uploadCameraMatrices(GameObject *camera) {
    for (auto &shaderProgram : shaderPrograms) {
        if (shaderProgram != nullptr) {
            shaderProgram->bind();

            shaderProgram->setUniformValue(Uniform::PROJECTION,
                                           camera->getComponent<Camera>()
                                                 ->getProjectionMatrix());

            shaderProgram->setUniformValue(Uniform::VIEW,
                                           camera->getComponent<Transform>()
                                                 ->getWorldToLocalMatrix());
        }
    }
}

}  // namespace ge::RenderPipeline
